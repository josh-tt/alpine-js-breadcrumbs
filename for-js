// TODO:
// Window history for back button option
// Build href array history and use that for back button so that dynamic url inputs can be traced back
export default (
	{
		disabled = false,
		href = '',
		home = true,
		allowOneItem = true,
		back = false,
		referrerUrl = true,
		last = false,
		lettercase = 'uppercase',
		title = false,
		stripDashes = true,
		stripUnderscores = true,
		trailingSlash = true,
		blacklistUrls = [],
		whitelistUrls = [],
		stringReplace = true,
		stringReplacements = [],
		showFirstOnly = false,
		showPreviousOnly = false,
		svg = 'home',
		homeSvg = '<svg viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">  <path fill-rule="evenodd" d="M9.293 2.293a1 1 0 011.414 0l7 7A1 1 0 0117 11h-1v6a1 1 0 01-1 1h-2a1 1 0 01-1-1v-3a1 1 0 00-1-1H9a1 1 0 00-1 1v3a1 1 0 01-1 1H5a1 1 0 01-1-1v-6H3a1 1 0 01-.707-1.707l7-7z" clip-rule="evenodd" /></svg>',
		backSvg = '<svg viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">  <path fill-rule="evenodd" d="M17 10a.75.75 0 01-.75.75H5.612l4.158 3.96a.75.75 0 11-1.04 1.08l-5.5-5.25a.75.75 0 010-1.08l5.5-5.25a.75.75 0 111.04 1.08L5.612 9.25H16.25A.75.75 0 0117 10z" clip-rule="evenodd" /></svg>',
		altSvg = '<svg viewBox="0 0 20 20" fill="currentColor" class="w-5 h-5">  <path fill-rule="evenodd" d="M4.25 2A2.25 2.25 0 002 4.25v2.5A2.25 2.25 0 004.25 9h2.5A2.25 2.25 0 009 6.75v-2.5A2.25 2.25 0 006.75 2h-2.5zm0 9A2.25 2.25 0 002 13.25v2.5A2.25 2.25 0 004.25 18h2.5A2.25 2.25 0 009 15.75v-2.5A2.25 2.25 0 006.75 11h-2.5zm9-9A2.25 2.25 0 0011 4.25v2.5A2.25 2.25 0 0013.25 9h2.5A2.25 2.25 0 0018 6.75v-2.5A2.25 2.25 0 0015.75 2h-2.5zm0 9A2.25 2.25 0 0011 13.25v2.5A2.25 2.25 0 0013.25 18h2.5A2.25 2.25 0 0018 15.75v-2.5A2.25 2.25 0 0015.75 11h-2.5z" clip-rule="evenodd" /></svg>',
	} ) => ( {

	// OPTIONS
	disabled, // Disables the crumbs by emptying the array which allows automatic hide/show. Bypassed urls will set disable to be true.
	href, // The current url or the user input url
	home, // Show the home or first crumb (if back is on, back is home and home is first)
	allowOneItem, // show the breadcrumb even if there is only one item
	back, // Replace the first item with 'back' text
	referrerUrl, // use the window referrer url as the back url
	last, // Show last item
	title, // use document title for the last item
	lettercase, // uppercase, lowercase, capitalize
	stripDashes, // Remove dashes from the crumb names
	stripUnderscores, // Remove underscores from the crumb names
	trailingSlash, // Add trailing slash to the generated hrefs
	whitelistUrls: [
		...whitelistUrls, // User defined urls to enable breadcrumbs on - setting disabled to false (opposite of blacklistUrls) - // Use a regex wildcard to match multiple urls
		// 'http://something.com/foo/*',

	],
	blacklistUrls: [
		...blacklistUrls, // User defined urls to bypass (others below are built-in - can't be changed) - // Use a regex wildcard to match multiple urls
		// 'http://something.com/bar/*',
	],
	stringReplace, // Enable string replacement
	stringReplacements: [
		...stringReplacements, // User defined string replacements (others below are built-in - can't be changed)
		{
			find: 'bird',
			replace: 'birdie',
			path: '/dogs/cats/some-bird',
			pattern: '',
		},
		{
			find: 'BAZ',
			replace: 'replaced texts',
			path: '/foo/baz',
			pattern: '',
		},
		{
			find: '',
			replace: '',
			path: '',
			pattern: 'https://dogs.com/dogs/(.*)', // Todo: Reimplement pattern from previous version
		},
	],
	showFirstOnly, // only show the first item
	showPreviousOnly, // only show the previous item
	svg, // 'home', 'back', 'alt'
	homeSvg, // Svg markup for home
	backSvg, // Svg markup for back
	altSvg, // Svg markup for alt

	// GETTERS
	get url() {
		const h = this.href ? this.href : window.location.href;
		this.maybeDisable( h );
		console.log( h );

		return h;
	},

	get urlObj() {
		const obj = new URL( this.url );
		const pathname = obj.pathname;
		const domain = obj.hostname;
		const search = obj.search;
		const searchParms = obj.searchParams;
		const hash = obj.hash;

		return {
			pathname,
			domain,
			search,
			searchParms,
			hash,
		};
	},

	get breadcrumbs() {
		if ( ! this.disabled ) {
			const pathname = this.urlObj.pathname;
			const crumbs = this.createBreadcrumbs( pathname ).filter( ( item ) => item.name !== '' );
			return crumbs;
		}

		return [];
	},

	get queryCrumbs() {
		if ( ! this.disabled ) {
			const search = this.urlObj.search;
			const searchParms = this.urlObj.searchParms;
			const queryCrumbs = this.createQueryCrumbs( search, searchParms );
			return queryCrumbs;
		}

		return [];
	},

	get hashCrumb() {
		if ( ! this.disabled ) {
			const hash = this.urlObj.hash;
			const hashCrumb = this.createHashCrumb( hash );
			return hashCrumb;
		}

		return [];
	},

	// Functions
	maybeDisable( url ) {
		if ( this.whitelistUrls.length > 0 ) {
			// Use match to check if the url is in the whitelist
			const whitelistMatch = this.whitelistUrls.some( ( item ) => {
				const regex = new RegExp( item );
				return regex.test( url );
			} );
			if ( ! whitelistMatch ) {
				this.disabled = ! this.disabled;
			}
		}
		if ( this.blacklistUrls.length > 0 ) {
			const blacklistMatch = this.blacklistUrls.some( ( item ) => {
				const regex = new RegExp( item );
				return regex.test( url );
			} );
			if ( blacklistMatch ) {
				this.disabled = ! this.disabled;
			}
		}
	},

	createBreadcrumbs( path ) {
		// Return home if path === '/'
		if ( path === '/' ) {
			return [ {
				name: 'Home',
				path: '/',
			} ];
		}

		let crumbs = [];

		// Split the path into an array of strings
		crumbs = path.split( '/' );
		crumbs = crumbs.map( ( breadcrumb, index ) => {
			// Replace the first item in the array with Home and the path with /
			if ( index === 0 ) {
				breadcrumb = 'Home';
				return {
					name: breadcrumb,
					path: '/',
				};
			}

			// If count is greater than 1, add the previous breadcrumb to the path
			return {
				name: breadcrumb,
				path: crumbs.slice( 0, index + 1 ).join( '/' ),
			};
		} );

		// Handle home, back and last options
		this.handleHome( crumbs );
		this.handleBack( crumbs );
		this.handleLast( crumbs );
		// Handle symbols and casings
		this.handleDashes( crumbs );
		this.handleUnderscores( crumbs );
		this.handleTrailingSlash( crumbs );
		this.handleLetterCase( crumbs );
		this.handleStringReplace( crumbs );
		// Remove items
		this.handleFirstOnly( crumbs );
		this.handlePreviousOnly( crumbs );
		// Attach Svgs
		this.handleSvg( crumbs );
		// Finalize
		this.handleAllowOneItem( crumbs );

		return crumbs;
	},

	createQueryCrumbs( search, searchParms ) {
		if ( search === '' ) {
			return [];
		}
		const queryCrumbs = [];
		searchParms.forEach( ( value, key ) => {
			queryCrumbs.push( {
				name: key,
				value,
			} );
		} );

		// Handle symbols and casings
		this.handleDashes( queryCrumbs );
		this.handleUnderscores( queryCrumbs );
		this.handleLetterCase( queryCrumbs );
		// Todo: handle string replace

		return queryCrumbs;
	},

	createHashCrumb( hash ) {
		if ( hash === '' ) {
			return [];
		}
		const hashCrumb = [ {
			name: hash.replace( '#', '' ),
			path: hash,
		} ];

		// Handle symbols and casings
		this.handleDashes( hashCrumb );
		this.handleUnderscores( hashCrumb );
		this.handleLetterCase( hashCrumb );
		// Todo: handle string replace

		return hashCrumb;
	},

	handleSvg( crumbs ) {
		if ( this.svg === 'home' ) {
			crumbs[ 0 ].svg = this.homeSvg;
		} else if ( this.svg === 'back' ) {
			crumbs[ 1 ].svg = this.backSvg;
		} else if ( this.svg === 'alt' ) {
			crumbs[ crumbs.length - 1 ].svg = this.altSvg;
		} else if ( this.svg === '' ) {
			crumbs[ 0 ].svg = '';
		}
	},

	handleAllowOneItem( crumbs ) {
		if ( ! this.allowOneItem && crumbs.length === 1 ) {
			crumbs.length = 0;
		}
	},

	handleHome( crumbs ) {
		if ( ! this.home ) {
			if ( crumbs[ 0 ].path === '/' ) {
				// Remove it from array
				crumbs.shift();
			}
		}
	},

	handleBack( crumbs ) {
		// If back is true, replace first item with 'back' text
		if ( this.back ) {
			crumbs[ 0 ].name = 'Back';
		}
		if ( this.referrerUrl ) {
			// Check if referrer is for this domain, if it is, use it
			if ( document.referrer.includes( this.urlObj.domain ) ) {
				crumbs[ 0 ].path = document.referrer;
			}
		}
	},

	handleFirstOnly( crumbs ) {
		if ( this.showFirstOnly ) {
			crumbs.length = 1;
		}
	},

	handlePreviousOnly( crumbs ) {
		if ( this.showPreviousOnly ) {
			// Get the second to last item in array and remove everything else
			const lastItem = crumbs[ crumbs.length - 2 ];
			if ( lastItem ) {
				crumbs.length = 0;
				crumbs.push( lastItem );
			}
		}
	},

	handleLast( crumbs ) {
		// If last is false, remove last item
		if ( ! this.last ) {
			crumbs.pop();
		}
		if ( this.last ) {
			// Use the document title
			if ( this.useTitle ) {
				crumbs[ crumbs.length - 1 ].name = document.title;
			}
		}
	},

	handleTrailingSlash( crumbs ) {
		if ( this.trailingSlash ) {
			// Add trailing slash to each crumb
			crumbs.map( ( crumb ) => {
				if ( ! crumb.path.endsWith( '/' ) ) {
					crumb.path = `${ crumb.path }/`;
				}
			} );
			return;
		}
		// If path is not equal to '/', remove trailing slash
		crumbs.map( ( crumb ) => {
			if ( crumb.path !== '/' && crumb.path.endsWith( '/' ) ) {
				crumb.path = crumb.path.slice( 0, -1 );
			}
		} );
	},

	handleLetterCase( crumbs ) {
		if ( this.lettercase === 'lowercase' ) {
			crumbs.map( ( crumb ) => {
				crumb.name = crumb.name.toLowerCase();
			} );
			return;
		}
		if ( this.lettercase === 'uppercase' ) {
			crumbs.map( ( crumb ) => {
				crumb.name = crumb.name.toUpperCase();
			} );
			return;
		}
		if ( this.lettercase === 'capitalize' ) {
			crumbs.map( ( crumb ) => {
				crumb.name = crumb.name.charAt( 0 ).toUpperCase() + crumb.name.slice( 1 );
			} );
		}
	},

	handleDashes( crumbs ) {
		if ( this.stripDashes ) {
			crumbs.map( ( crumb ) => {
				crumb.name = crumb.name.replace( /-/g, ' ' );
			} );
		}
	},

	handleUnderscores( crumbs ) {
		if ( this.stripUnderscores ) {
			crumbs.map( ( crumb ) => {
				crumb.name = crumb.name.replace( /_/g, ' ' );
			} );
		}
	},

	handleStringReplace( crumbs ) {
		if ( this.stringReplace ) {
			crumbs.map( ( crumb ) => {
				this.stringReplacements.forEach( ( replace ) => {
					// If path is not empty and path matches, do the find replace
					if ( replace.path !== '' ) {
						// Pre-format the replacement path trailing slashes to match user setting to avoid typos
						if ( this.trailingSlash ) {
							replace.path = this.addTrailingSlash( replace.path );
						} else {
							replace.path = this.removeTrailingSlash( replace.path );
						}
						// If the path matches
						if ( crumb.path === replace.path ) {
							// If find is empty, replace the crumb name with replace name
							if ( replace.find === '' ) {
								crumb.name = replace.replace;
							} else {
							// If find is not empty, do the find replace
								crumb.name = crumb.name.replace( replace.find, replace.replace );
							}
						}
						// If path is empty, do the find replace
					} else if ( replace.path === '' ) {
						crumb.name = crumb.name.replace( replace.find, replace.replace );
					}
				} );
			} );
		}
	},

	// Helpers
	addTrailingSlash: ( path ) => ( path.endsWith( '/' ) ? path : `${ path }/` ),
	removeTrailingSlash: ( path ) => ( path.endsWith( '/' ) ? path.slice( 0, -1 ) : path ),
	setTitleCase: ( str ) => str.replace( /(\w)(\w*)/g, ( g0, g1, g2 ) => g1.toUpperCase() + g2.toLowerCase() ),
	setLowerCase: ( str ) => str.replace( /(\w)(\w*)/g, ( g0, g1, g2 ) => g1.toLowerCase() + g2.toLowerCase() ),

	init() {
		this.maybeDisable( this.href );
	},

} );
